各个知识点总结:

类型 Two pointers

1) Binary Search

数组必须是有序的并检查数组是否为空. 用数组的中间数和target比较, 比target小则在左边区域继续寻找, 比target大则在右边区域继续寻找,
若相等则返回, 否则返回不存在.

时间复杂度 O(logn)
空间复杂度 O(1)

记忆点: 一个while循环, 取中间值操作在while循环中, 因为每次while循环都要选择在左边还是在右边寻找.

2) QuickSort

https://github.com/Huctor/Algorithm/blob/main/TwoPointers/Sort%20an%20Array(QuickSort%2C%20Two%20pointers)

首先检测数组是否为空. 一般采用数组中间数为参照值, 然后在while循环中依次移动左右两个指针, 一个从左边一直移动指针寻找到比参照值大的数(通过while循环), 
一个从右边一直移动指针寻找到比中间值小的数(通过while循环). 寻找到两个值之后交换, 并依次移动左右两个指针. 最后调用两次quicksort函数本身, 分别对数组
做半段和右半段进行quicksort排序.

时间复杂度 O(n)
空间复杂度 O(1)

记忆点: 三个while循环, 取中间值在while循环之外,每次调用函数的时候才需要取中间值, while循环内部只需要移动指针.
函数体内还需要两次再调用函数本身, 依次继续在左右半段继续排序, 直到完成.

3) Two sum 返回数组中两数相加和等于target的下标

https://github.com/Huctor/Algorithm/blob/main/TwoPointers/Two%20sum(Two%20pointers%2C%20Dictionary)

使用字典, 用数组元素的值作为字典的key, 用index作为字典的value.

时间复杂度 O(n)
空间复杂度 O(n)

记忆点: 字典的创建 var dic = [Int:Int]()

4) Sliding windows 返回字符串中最长的非重复部分长度

https://github.com/Huctor/Algorithm/blob/main/TwoPointers/Longest%20Substring%20Without%20Repeating%20Characters(经典滑动窗口问题sliding%20windows)

使用set记录所有滑过的字符. 需要两个指针同向滑动, 外面一个while循环, 左指针不动, 右指针依次移动(同时set添加右指针滑动的字符), 直到碰到重复的字符(set中是否已包含该字符),
然后进入一个内层的while循环, 这个内部的while循环中只移动左指针(set同时移除左指针滑动过的字符), 直到左指针找到和右指针相同的字符, 使用break退出内层while循环(set移除和右指针相同的字符
同时左指针继续移动1个字符). 注意外层while中始终记录右指针和左指针的距离. 如此, 直到右指针移动到字符串末端.

时间复杂度 O(n)
空间复杂度 O(k) k为set的长度

记忆点: 两个while循环(外层为右指针, 内层为左指针), set用作检查重复字符. set的创建var collections = Set<Character>()

5) Fast and slow pointer 判断一个链表是否是一个环

https://github.com/Huctor/Algorithm/blob/main/TwoPointers/Linked%20List%20Cycle(fast%20and%20slow%20pointer)

一个while循环, 慢指针走一步, 快指针走两步, 有重合则证明有环, 没有重合或者快指针的为nil或者快指针的next为nil则证明没有环.

时间复杂度 O(n)
空间复杂度 O(1)

记忆点: 由于是链表, 走一步的和走两步的例子为slow = slow?.next和fast = fast?.next?.next
另外, while循环的退出条件为fast快指针为空或者fast!.next为空, 意为快指针已经走到的链表末端并没有环


类型 LinkedList

1) Reverse Linked List 反转链表

https://github.com/Huctor/Algorithm/blob/main/Exercices/206.%20Reverse%20Linked%20List(Linked%20list)

Iterative解法

流程:
创建一个新链表头部newHead, 从旧链表中取出一个节点插入新链表头部, 然后再将newHead换到头部即可(即将新插入的节点赋值给newHead).
注意这里简单赋值即可, 因为节点插入之后已经存在一个新链表在内存中, 由于都是object, 所以只要更新newHead为最新节点即可, 更新newHead
并不会影响已经在内存中生成的新链表, 只是为了返回需要.

while inputHead != nil{
    var next = inputHead!.next //Line 1
    inputHead!.next = newHead // Line 2
    newHead = inputHead //Line 3
    inputHead = next // Line 4
}

代码思路:
1 首先把旧链表head第二个值取出来备用, 因为之后要循环, 由此而得来Line 1
2 把备用值赋给head, 用来继续循环, 由此得来Line 4
3 把旧链表head添加到新链表头部, 具体做法为把head的next设置为newHead，由此而来Line 2
4 然后更新newHead的值为head, 以保持newHead始终为新链表的头部, 由此而来Line 3

时间复杂度 O(n)
空间复杂度 O(1)

记忆点: 更新头部节点, 只需要简单赋值就好, 不会影响已建立的存在在内存中的新链表

Recursive解法

待补充...


类型 BFS

1) 01 Matrix 给出一个2维矩阵, 返回一个2维矩阵表示出每个非0元素到0的距离

https://leetcode.com/problems/01-matrix/

思路:

先将图中所有





































